{
prev = matrix(0,1,nrow(ins.ver))
#predict in tutto il dataset
for (i in 1:max_part)
{
if (i == 1)
{
min = 1
max = div
}
else
{
min = (i-1)*div+1
if(min > nrow(ins.ver))
break
max = i*div
if(max > nrow(ins.ver))
max = nrow(ins.ver)
}
print(min)
print(max)
matrice_svm=cbind(svm_data(0, dictionary, min,max), #object
svm_data(1,domain, min,max),     #domain
svm_data(2,motivation,min,max),   #motivation
as.numeric(ins.ver[min:max,4]), #fascia
as.numeric(ins.ver[min:max,11]),#internal
as.numeric(ins.ver[min:max,15]),#sbloccata
as.numeric(ins.ver[min:max,16]),#sent
as.numeric(ins.ver[min:max,17]) #nchar
)
tmp=predict(model,matrice_svm)
prev[1,min:max]=tmp
}
return(prev)
}
}
train<-function(max_part, div, ins.stima, dictionary, domain, motivation, model)
{
for (i in 1:max_part)
{
if (i == 1)
{
min = 1
max = div
}
else
{
min = (i-1)*div+1
if(min > nrow(ins.stima))
break
max = i*div
if(max > nrow(ins.stima))
max = nrow(ins.stima)
}
print(min)
print(max)
matrice_svm=cbind(svm_data(0, dictionary, min,max), #object
svm_data(1,domain, min,max),     #domain
svm_data(2,motivation,min,max),   #motivation
as.numeric(ins.stima[min:max,4]), #fascia
as.numeric(ins.stima[min:max,11]),#internal
as.numeric(ins.stima[min:max,15]),#sbloccata
as.numeric(ins.stima[min:max,16]),#sent
as.numeric(ins.stima[min:max,17]) #nchar
)
print("allenamento modello")
model <- onlearn(model_pass,matrice_svm,y_binary[min:max,],nu=0.03,lambda=0.1) #da modificare nella verifica
}
return(model)
}
set.seed(123)
campione= sample(1:nrow(datidef),as.integer(nrow(datidef)*0.7))# regola del 70-30 (per dati completi sarebbe 365000)
ins.stima= datidef[campione,]
ins.ver = datidef[-campione,]
col = length(dictionary)+length(domain)+length(motivation)+5 #+5=fascia+internal+sbloccata+sent+nchars
y_binary<-matrix(-1,nrow=nrow(ins.stima),1)
for (k in 1: nrow(ins.stima))       # classificazione ONE vs ONE
{
if (as.numeric(ins.stima[k,6])==0) #passate contro all
{
y_binary[k,1]=1
}
}
model_pass <- inlearn(col,kernel="rbfdot",kpar=list(sigma=0.2),type="classification")
div = 1000 #la dim del campione per ogni ciclo
last = FALSE
max_part = as.integer(nrow(ins.stima)/div) #numero massimo di cicli che dovrà fare
if (nrow(ins.stima)!=div*max_part)
{
max_part = max_part+1             #aggiusto e porto da 72.72 a 73 per rendere intero il numero
}
if (max_part > 1)
{
model_pass= train(max_part, div, ins.stima, dictionary, domain, motivation, model_pass)
}
col = length(dictionary)+length(domain)+length(motivation)+5 #+5=fascia+internal+sbloccata+sent+nchars
y_binary<-matrix(-1,nrow=nrow(ins.stima),1)
for (k in 1: nrow(ins.stima))       # classificazione ONE vs ONE
{
if (as.numeric(ins.stima[k,6])==0) #passate contro all
{
y_binary[k,1]=1
}
}
model_pass <- inlearn(col,kernel="rbfdot",kpar=list(sigma=0.2),type="classification")
div = 1000 #la dim del campione per ogni ciclo
last = FALSE
max_part = as.integer(nrow(ins.stima)/div) #numero massimo di cicli che dovrà fare
if (nrow(ins.stima)!=div*max_part)
{
max_part = max_part+1             #aggiusto e porto da 72.72 a 73 per rendere intero il numero
}
if (max_part > 1)
{
model_pass= train(max_part, div, ins.stima, dictionary, domain, motivation, model_pass)
}
# Chiamiamo i pacchetti necessari
library(MASS)
library(tidyverse)
library(tm)
library(lsa) #pacchetto per le stopwords in più lingue
library(caret)
library(wordcloud)
library(devtools) #installarla se necessario
library (TextWiller)
library(ggplot2)
require(tau)
library(e1071) #svm tradizionale
library(ggplot2)
library(SnowballC)
library(kernlab) #svm online
col = length(dictionary)+length(domain)+length(motivation)+5 #+5=fascia+internal+sbloccata+sent+nchars
y_binary<-matrix(-1,nrow=nrow(ins.stima),1)
for (k in 1: nrow(ins.stima))       # classificazione ONE vs ONE
{
if (as.numeric(ins.stima[k,6])==0) #passate contro all
{
y_binary[k,1]=1
}
}
model_pass <- inlearn(col,kernel="rbfdot",kpar=list(sigma=0.2),type="classification")
div = 1000 #la dim del campione per ogni ciclo
last = FALSE
max_part = as.integer(nrow(ins.stima)/div) #numero massimo di cicli che dovrà fare
if (nrow(ins.stima)!=div*max_part)
{
max_part = max_part+1             #aggiusto e porto da 72.72 a 73 per rendere intero il numero
}
if (max_part > 1)
{
model_pass= train(max_part, div, ins.stima, dictionary, domain, motivation, model_pass)
}
prev_pass = prediction(max_part, ins.ver, div, model_pass)
x = which.max(prev_pass[1,])
print(prev_pass[1,x])
x = which.min(prev_pass[1,])
print(prev_pass[1,x])
length(dictionary)
# Chiamiamo i pacchetti necessari
library(MASS)
library(tidyverse)
library(tm)
library(lsa) #pacchetto per le stopwords in più lingue
library(caret)
library(wordcloud)
library(devtools) #installarla se necessario
library (TextWiller)
library(ggplot2)
require(tau)
library(e1071) #svm tradizionale
library(ggplot2)
library(SnowballC)
library(kernlab) #svm online
svm_data <- function(type, vector, min, max)
{
# la variabile type contiene il fatto che si debba calcolare objdef, domdef o altro
# la variabile vector contiene il dizionario di parole o di dominii in base al type
# min % max è il range di indice di datidef che vengono analizzati
# in una singola esecuzione per il calcolo degli input/output di svm
# SEMPLICE: creo objdef e domdef per le righe di datidef che vanno da min a max ;)
if (type == 0) # calcolo di objdef
{
print("objdef creazione inizio")
mat = matrix(0, nrow=(max-min + 1), ncol=length(dictionary))
index = 0
for (i in 1:(max-min+1))
{
#print(i)
obj = strsplit(toString(ins.stima[min +index, 12]), " ") #datidef
for (j in 1:length(obj[[1]]))
{
obj[[1]][j] = wordStem(obj[[1]][j], language = "english")
obj[[1]][j] = wordStem(obj[[1]][j], language = "italian")
obj[[1]][j] = wordStem(obj[[1]][j], language = "spanish")
obj[[1]][j] = wordStem(obj[[1]][j], language = "danish")
obj[[1]][j] = wordStem(obj[[1]][j], language = "french")
obj[[1]][j] = wordStem(obj[[1]][j], language = "german")
}
#print(obj[[1]])
for (k in 1:length(obj[[1]]))
{
if (obj[[1]][k]!= "")
{
position=pmatch(obj[[1]][k], dictionary)
#print(position[[1]])
#print("ok")
if (is.na(position[[1]])==FALSE)
{
#print(length(dictionary))
#print(ncol(mat))
mat[i,position[[1]]]=1
}
}
}
index=index+1
}
}
else if (type == 1) # calcolo di domdef
{
print("domdef creazione")
mat = matrix(0, nrow=(max-min +1), ncol=length(domain))
index = 0
for (i in 1:(max-min+1))
{
#print(i)
obj = as.matrix(as.character(ins.stima[min +index,8]))#datidef
for (k in 1:nrow(obj))
{
mittenti=pmatch(obj[k,], domain)
#print(mittenti[[1]])
#print("ok")
if (is.na(mittenti[[1]])==FALSE)
{
#print(length(domain)) #domain è lungo 189
#print(ncol(mat))
mat[i,mittenti]=1
}
}
index= index + 1
}
}
else if (type == 2) # calcolo motivation
{
print("motivation creazione")
mat = matrix(0, nrow=(max-min +1), ncol=length(motivation))
index = 0
for (i in 1:(max-min+1))
{
#print(i)
obj = as.matrix(as.character(ins.stima[min +index,14]))#datidef
for (k in 1:nrow(obj))
{
motivazione=pmatch(obj[k,], motivation)
#print(mittenti[[1]])
#print("ok")
if (is.na(motivazione[[1]])==FALSE)
{
#print(length(domain)) #domain è lungo 189
#print(ncol(mat))
mat[i,motivazione]=1
}
}
index= index + 1
}
}
return(mat)
}
order_freq<-function(dictionary, freq_obj_tot)
{
index = as.integer(1:length(dictionary))
# ordino le frequenze in ordine decrescente
for (i in 1:length(freq_obj_tot))
{
idxmax = which.max(freq_obj_tot[i:ncol(freq_obj_tot)])
idxmax = idxmax+i-1
freq = freq_obj_tot[i]
freqid = index[i]
freq_obj_tot[i]= freq_obj_tot[idxmax]
index[i]= index[idxmax]
freq_obj_tot[idxmax]=freq
index[idxmax]=freqid
}
colnames = character(length(freq_obj_tot))
for (i in 1:length(dictionary))
{
colnames[i]=dictionary[index[i]]
}
return(colnames)
}
prediction<-function(max_part, ins.ver, div, model)
{
if (max_part > 1)
{
prev = matrix(0,1,nrow(ins.ver))
#predict in tutto il dataset
for (i in 1:max_part)
{
if (i == 1)
{
min = 1
max = div
}
else
{
min = (i-1)*div+1
if(min > nrow(ins.ver))
break
max = i*div
if(max > nrow(ins.ver))
max = nrow(ins.ver)
}
print(min)
print(max)
matrice_svm=cbind(svm_data(0, dictionary, min,max), #object
svm_data(1,domain, min,max),     #domain
svm_data(2,motivation,min,max),   #motivation
as.numeric(ins.ver[min:max,4]), #fascia
as.numeric(ins.ver[min:max,11]),#internal
as.numeric(ins.ver[min:max,15]),#sbloccata
as.numeric(ins.ver[min:max,16]),#sent
as.numeric(ins.ver[min:max,17]) #nchar
)
tmp=predict(model,matrice_svm)
prev[1,min:max]=tmp
}
return(prev)
}
}
train<-function(max_part, div, ins.stima, dictionary, domain, motivation, model)
{
for (i in 1:max_part)
{
if (i == 1)
{
min = 1
max = div
}
else
{
min = (i-1)*div+1
if(min > nrow(ins.stima))
break
max = i*div
if(max > nrow(ins.stima))
max = nrow(ins.stima)
}
print(min)
print(max)
matrice_svm=cbind(svm_data(0, dictionary, min,max), #object
svm_data(1,domain, min,max),     #domain
svm_data(2,motivation,min,max),   #motivation
as.numeric(ins.stima[min:max,4]), #fascia
as.numeric(ins.stima[min:max,11]),#internal
as.numeric(ins.stima[min:max,15]),#sbloccata
as.numeric(ins.stima[min:max,16]),#sent
as.numeric(ins.stima[min:max,17]) #nchar
)
print("allenamento modello")
model <- onlearn(model_pass,matrice_svm,y_binary[min:max,],nu=0.03,lambda=0.1) #da modificare nella verifica
}
return(model)
}
set.seed(123)
campione= sample(1:nrow(datidef),as.integer(nrow(datidef)*0.7))# regola del 70-30 (per dati completi sarebbe 365000)
ins.stima= datidef[campione,]
ins.ver = datidef[-campione,]
col = length(dictionary)+length(domain)+length(motivation)+5 #+5=fascia+internal+sbloccata+sent+nchars
y_binary<-matrix(-1,nrow=nrow(ins.stima),1)
for (k in 1: nrow(ins.stima))       # classificazione ONE vs ONE
{
if (as.numeric(ins.stima[k,6])==0) #passate contro all
{
y_binary[k,1]=1
}
}
model_pass <- inlearn(col,kernel="vanilladot",kpar=list(),type="classification")
div = 1000 #la dim del campione per ogni ciclo
last = FALSE
max_part = as.integer(nrow(ins.stima)/div) #numero massimo di cicli che dovrà fare
if (nrow(ins.stima)!=div*max_part)
{
max_part = max_part+1             #aggiusto e porto da 72.72 a 73 per rendere intero il numero
}
if (max_part > 1)
{
model_pass= train(max_part, div, ins.stima, dictionary, domain, motivation, model_pass)
}
start = system.time()
start = system.time(for (k in 1: nrow(ins.stima))       # classificazione ONE vs ONE
{
if (as.numeric(ins.stima[k,6])==0) #passate contro all
{
y_binary[k,1]=1
}
})
start
start[1]
col = length(dictionary)+length(domain)+length(motivation)+5 #+5=fascia+internal+sbloccata+sent+nchars
y_binary<-matrix(-1,nrow=nrow(ins.stima),1)
for (k in 1: nrow(ins.stima))       # classificazione ONE vs ONE
{
if (as.numeric(ins.stima[k,6])==0) #passate contro all
{
y_binary[k,1]=1
}
}
model_pass <- inlearn(col,kernel="vanilladot",kpar=list(),type="classification")
div = 1000 #la dim del campione per ogni ciclo
last = FALSE
max_part = as.integer(nrow(ins.stima)/div) #numero massimo di cicli che dovrà fare
if (nrow(ins.stima)!=div*max_part)
{
max_part = max_part+1             #aggiusto e porto da 72.72 a 73 per rendere intero il numero
}
if (max_part > 1)
{
time_pass = system.time(model_pass= train(max_part, div, ins.stima, dictionary, domain, motivation, model_pass))
}
col = length(dictionary)+length(domain)+length(motivation)+5 #+5=fascia+internal+sbloccata+sent+nchars
y_binary<-matrix(-1,nrow=nrow(ins.stima),1)
for (k in 1: nrow(ins.stima))       # classificazione ONE vs ONE
{
if (as.numeric(ins.stima[k,6])==0) #passate contro all
{
y_binary[k,1]=1
}
}
model_pass <- inlearn(col,kernel="vanilladot",kpar=list(),type="classification")
div = 1000 #la dim del campione per ogni ciclo
last = FALSE
max_part = as.integer(nrow(ins.stima)/div) #numero massimo di cicli che dovrà fare
if (nrow(ins.stima)!=div*max_part)
{
max_part = max_part+1             #aggiusto e porto da 72.72 a 73 per rendere intero il numero
}
time_pass=system.time(if (max_part > 1)
{
model_pass= train(max_part, div, ins.stima, dictionary, domain, motivation, model_pass)
})
prev_pass = prediction(max_part, ins.ver, div, model_pass)
max = which.max(prev_pass)
prev_pass=prev_pass/prev_pass[max]
x = which.max(prev_pass)
print(prev_pass[x])
x = which.min(prev_pass)
print(prev_pass[x])
for (i in 1:length(prev_pass))
{
if(prev_pass[i]>0.97)
{
print(i)
}
}
length(prev_pass)
for (i in 1:length(prev_pass))
{
if(prev_pass[i]>0.9)
{
print(i)
}
}
for (i in 1:length(prev_pass))
{
if(prev_pass[i]>0.7)
{
print(i)
}
}
for (i in 1:length(prev_pass))
{
if(prev_pass[i]>0.8)
{
print(i)
}
}
for (i in 1:length(prev_pass))
{
if(prev_pass[i]>0.75)
{
print(i)
}
}
k=0
for (i in 1:length(prev_pass))
{
if(prev_pass[i]>0.73)
{
k=k+1
}
}
print(k)
k=0
for (i in 1:length(prev_pass))
{
if(prev_pass[i]>0.74)
{
k=k+1
}
}
print(k)
k=0
for (i in 1:length(prev_pass))
{
if(prev_pass[i]>0.73)
{
k=k+1
}
}
print(k)
table(prev_pass)
k=table(prev_pass)
k
