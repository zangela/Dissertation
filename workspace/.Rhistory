#
#
#
##################################################################
make_dictionary <- function(corpus, tmp)
{
dtm = as.matrix(DocumentTermMatrix(corpus
, control = list( stemming = TRUE, stopwords = itastopwords,
minWordLength = 2, removeNumbers = TRUE,
removePunctuation = FALSE, bounds=list(local = c(1,Inf)) ))
)
coln = colnames(dtm)
dic = rep("", length(coln)+length(tmp))
for (i in 1:length(coln))
{
dic[i]=coln[i]
}
k = length(coln)+1
if(length(tmp > 0))
{
for (i in 1:length(tmp))
{
dic[k]=tmp[i]
k = k+1
}
}
return(dic)
}
n_part = 50
part = as.integer(nrow(datidef)/n_part)
tmp = rep("", 0)
for (i in 1:(n_part+1))
{
if (i <= 50)
{
if (i == 1)
{
corpus = Corpus(VectorSource(datidef[1:part*i,12]))
tmp = make_dictionary(corpus,tmp)
}
else
{
corpus = Corpus(VectorSource(datidef[(part*(i-1)+1):(part*i),12]))
tmp = make_dictionary(corpus,tmp)
}
}
else
{
if (part*(i-1) < nrow(datidef))
{
corpus = Corpus(VectorSource(datidef[(part*(i-1)+1):nrow(datidef),12]))
dic = make_dictionary(corpus,tmp)
}
}
}
dic= wordStem(dic, language = "english")
dic= wordStem(dic, language = "italian")
dic= wordStem(dic, language = "spanish")
dic= wordStem(dic, language = "danish")
dic= wordStem(dic, language = "french")
dic= wordStem(dic, language = "german")
len = 0
idx = 1
dic=sort(dic)
colnfin = dic
#conto il numero di parole diverse in tutti gli oggetti
for (i in 2:length(dic))
{
if (colnfin[idx]!=dic[i])
{
len = len +1
idx = idx + 1
colnfin[idx]=dic[i]
}
}
#creo un vettore per memorizzare tutte le parole diverse (serve per colnames) e la matrice objdef finale
dictionary=character(len)
#inserisco tutte le parole diverse in oarine alfabetico in dictionary
for (i in 1:len)
{
dictionary[i]= colnfin[i]
}
length(dictionary)
##################################################################
#
#
#
#   fine CREAZIONE DEL DIZIONARIO NEL CASO ALLDEF.CSV
#   presente in ***dictionary***
#
#
##################################################################
##################################################################
#
#
#
#   inizio CREAZIONE DEI DOMINII NEL CASO ALLDEF.CSV
#   ha senso farlo su tutto il dataset
#
#
##################################################################
#ottengo tutti i dominii
len = 0
alldom=datidef[,8]
#dominii in ordine alfabetico
alldom= sort(alldom)
#conto e mi salvo tutti i dominii diversi
tmpdom = character(nrow(datidef))
idx=1
tmpdom[idx]=toString(alldom[idx])
len=1
for (i in 2:nrow(datidef))
{
if (tmpdom[idx]!=toString(alldom[i]))
{
len = len +1
idx=idx+1
tmpdom[idx]=toString(alldom[i])
}
}
#creo un vettore che contiene tutti i dominii Diversi
domain= character(len)
for (i in 1:len)
{
domain[i]=tmpdom[i]
}
length(domain)
##################################################################
#
#
#
#   fine CREAZIONE DEI DOMINII NEL CASO ALLDEF.CSV
#   presente in ***domain***
#
#
##################################################################
##################################################################
#
#
#
#   inizio CREAZIONE DELLE MOTIVAZIONI NEL CASO ALLDEF.CSV
#   ha senso farlo su tutto il dataset
#
#
##################################################################
#ottengo tutti i motivation
len = 0
allmot=datidef[,13]
#motivation in ordine alfabetico
allmot= sort(allmot)
#conto e mi salvo tutte le motivation diverse
tmpmot = character(nrow(datidef))
idx=1
tmpmot[idx]=""
len=1
for (i in 2:nrow(datidef))
{
if (tmpmot[idx]!=toString(allmot[i]))
{
len = len +1
idx=idx+1
tmpmot[idx]=toString(allmot[i]) #salvo le motivation diverse in modo unico
}
}
len = len -1 #ho tolto il primo carattere che Ã¨ "" utilizzato per saltare tutti quelli vuoti
#creo un vettore che contiene tutti le motivation Diversi
motivation= character(len)
idx = 2
for (i in 1:len)
{
motivation[i]=tmpmot[idx]
idx = idx +1
}
sent=sentiment(ins.stima[,12]) #"positivo" (+1), "negativo" (-1),  "neutro" (0)
#unisco giÃ  in datidef due dei predittori che mi serviranno poi per svm->manca perÃ² conteggio_caratteri che non funziona
ins.stima=cbind(ins.stima,sent,nchars)
svm_data <- function(type, vector, min, max)
{
# la variabile type contiene il fatto che si debba calcolare objdef, domdef o altro
# la variabile vector contiene il dizionario di parole o di dominii in base al type
# min % max Ã¨ il range di indice di datidef che vengono analizzati
# in una singola esecuzione per il calcolo degli input/output di svm
# SEMPLICE: creo objdef e domdef per le righe di datidef che vanno da min a max ;)
if (type == 0) # calcolo di objdef
{
mat = matrix(0, nrow=(max-min + 1), ncol=length(dictionary))
index = 0
for (i in 1:(max-min+1))
{
obj = strsplit(toString(ins.stima[min +index, 12]), " ") #datidef
for (j in 1:length(obj[[1]]))
{
obj[[1]][j] = wordStem(obj[[1]][j], language = "english")
obj[[1]][j] = wordStem(obj[[1]][j], language = "italian")
obj[[1]][j] = wordStem(obj[[1]][j], language = "spanish")
obj[[1]][j] = wordStem(obj[[1]][j], language = "danish")
obj[[1]][j] = wordStem(obj[[1]][j], language = "french")
obj[[1]][j] = wordStem(obj[[1]][j], language = "german")
}
#print(obj[[1]])
for (k in 1:length(obj[[1]]))
{
if (obj[[1]][k]!= "")
{
position=pmatch(obj[[1]][k], dictionary)
#print(position[[1]])
#print("ok")
if (is.na(position[[1]])==FALSE)
{
#print(length(dictionary))
#print(ncol(mat))
mat[i,position[[1]]]=1
}
}
}
index=index+1
}
}
else if (type == 1) # calcolo di domdef
{
mat = matrix(0, nrow=(max-min +1), ncol=length(domain))
index = 0
for (i in 1:(max-min+1))
{
obj = as.matrix(as.character(ins.stima[min +index,8]))#datidef
for (k in 1:nrow(obj))
{
mittenti=pmatch(obj[k,], domain)
#print(mittenti[[1]])
#print("ok")
if (is.na(mittenti[[1]])==FALSE)
{
#print(length(domain)) #domain Ã¨ lungo 189
#print(ncol(mat))
mat[i,mittenti]=1
}
}
index= index + 1
}
}
else if (type == 2) # calcolo motivation
{
mat = matrix(0, nrow=(max-min +1), ncol=length(motivation))
index = 0
for (i in 1:(max-min+1))
{
obj = as.matrix(as.character(ins.stima[min +index,13]))#datidef
for (k in 1:nrow(obj))
{
motivazione=pmatch(obj[k,], motivation)
#print(mittenti[[1]])
#print("ok")
if (is.na(motivazione[[1]])==FALSE)
{
#print(length(domain)) #domain Ã¨ lungo 189
#print(ncol(mat))
mat[i,motivazione]=1
}
}
index= index + 1
}
}
return(mat)
}
###########################################################
#SVM ONLINE
#LINK UTILE:
#https://cran.r-project.org/web/packages/kernlab/vignettes/kernlab.pdf    ->LINK PAPAER
#https://www.rdocumentation.org/packages/kernlab/versions/0.9-27/topics/onlearn     ->SPIEGAZIONE COMANDO ONLEARN
#https://www.rdocumentation.org/packages/kernlab/versions/0.9-27/topics/inlearn     ->SPIEGAZIONE COMANDO INLEARN
################################################################
col = length(dictionary)+length(domain)+length(motivation)+5 #+5=fascia+internal+sbloccata+sent+nchars
y_binary<-matrix(-1,nrow=nrow(ins.stima),1)
freq_obj_tot=matrix(0,2,ncol=length(dictionary)) #matrice in cui salverò tutti i conteggi dei vari cicli
model_rig <- inlearn(col,kernel="rbfdot",kpar=list(sigma=0.2),type="classification")
div = 10 #la dim del campione per ogni ciclo
last = FALSE
max_part = as.integer(nrow(ins.stima)/div) #numero massimo di cicli che dovrÃ  fare
if (nrow(ins.stima)!=div*max_part)
{
max_part = max_part+1             #aggiusto e porto da 72.72 a 73 per rendere intero il numero
}
if (max_part > 1)
{
for (i in 1:max_part)
{
if (i == 1)
{
min = 1
max = div
}
else
{
min = (i-1)*div+1
if(min > nrow(ins.stima))
break
max = i*div
if(max > nrow(ins.stima))
max = nrow(ins.stima)
}
matrice_svm=cbind(svm_data(0, dictionary, min,max), #object
svm_data(1,domain, min,max),      #domain
svm_data(2,motivation,min,max),   #motivation
as.numeric(ins.stima[min:max,4]), #fascia
as.numeric(ins.stima[min:max,11]),#internal
as.numeric(ins.stima[min:max,14]),#sbloccata
as.numeric(ins.stima[min:max,15]),#sent
as.numeric(ins.stima[min:max,16])) #nchar
}
}
freq_obj=matrix(0,1,ncol=length(dictionary))
#aggiungo il contatore
freq_obj=colSums((matrice_svm[,1:length(dictionary)]))
freq_obj_tot=freq_obj_tot[1,]+freq_obj #freq assolute
y_binary<-matrix(-1,nrow=nrow(ins.stima),1)
for (i in 1: nrow(ins.stima))
{
if (as.numeric(ins.stima[i,6])==1) #rigettate contro all
{
y_binary[i,1]=1
}
}
freq_obj=matrix(0,1,ncol=length(dictionary))
freq_obj_tot=matrix(0,2,ncol=length(dictionary)) #matrice in cui salverò tutti i conteggi dei vari cicli
model_rig <- inlearn(col,kernel="rbfdot",kpar=list(sigma=0.2),type="classification")
div = 10 #la dim del campione per ogni ciclo
last = FALSE
max_part = as.integer(nrow(ins.stima)/div) #numero massimo di cicli che dovrÃ  fare
if (nrow(ins.stima)!=div*max_part)
{
max_part = max_part+1             #aggiusto e porto da 72.72 a 73 per rendere intero il numero
}
if (max_part > 1)
{
for (i in 1:max_part)
{
if (i == 1)
{
min = 1
max = div
}
else
{
min = (i-1)*div+1
if(min > nrow(ins.stima))
break
max = i*div
if(max > nrow(ins.stima))
max = nrow(ins.stima)
}
matrice_svm=cbind(svm_data(0, dictionary, min,max), #object
svm_data(1,domain, min,max),      #domain
svm_data(2,motivation,min,max),   #motivation
as.numeric(ins.stima[min:max,4]), #fascia
as.numeric(ins.stima[min:max,11]),#internal
as.numeric(ins.stima[min:max,14]),#sbloccata
as.numeric(ins.stima[min:max,15]),#sent
as.numeric(ins.stima[min:max,16])) #nchar
#aggiungo il contatore
freq_obj=colSums((matrice_svm[,1:length(dictionary)]))
freq_obj_tot=freq_obj_tot[1,]+freq_obj #freq assolute
}
}
y_binary<-matrix(-1,nrow=nrow(ins.stima),1)
for (i in 1: nrow(ins.stima))
{
if (as.numeric(ins.stima[i,6])==1) #rigettate contro all
{
y_binary[i,1]=1
}
}
freq_obj=matrix(0,1,ncol=length(dictionary))
freq_obj_tot=matrix(0,1,ncol=length(dictionary)) #matrice in cui salverò tutti i conteggi dei vari cicli
model_rig <- inlearn(col,kernel="rbfdot",kpar=list(sigma=0.2),type="classification")
div = 10 #la dim del campione per ogni ciclo
last = FALSE
max_part = as.integer(nrow(ins.stima)/div) #numero massimo di cicli che dovrÃ  fare
if (nrow(ins.stima)!=div*max_part)
{
max_part = max_part+1             #aggiusto e porto da 72.72 a 73 per rendere intero il numero
}
if (max_part > 1)
{
for (i in 1:max_part)
{
if (i == 1)
{
min = 1
max = div
}
else
{
min = (i-1)*div+1
if(min > nrow(ins.stima))
break
max = i*div
if(max > nrow(ins.stima))
max = nrow(ins.stima)
}
matrice_svm=cbind(svm_data(0, dictionary, min,max), #object
svm_data(1,domain, min,max),      #domain
svm_data(2,motivation,min,max),   #motivation
as.numeric(ins.stima[min:max,4]), #fascia
as.numeric(ins.stima[min:max,11]),#internal
as.numeric(ins.stima[min:max,14]),#sbloccata
as.numeric(ins.stima[min:max,15]),#sent
as.numeric(ins.stima[min:max,16])) #nchar
#aggiungo il contatore
freq_obj=colSums((matrice_svm[,1:length(dictionary)]))
freq_obj_tot=freq_obj_tot+freq_obj #freq assolute
}
}
View(freq_obj_tot)
tot<-matrix(0,2,ncol=ncol(freq_obj_tot))
View(freq_obj_tot)
tot[1,]<-freq_obj_tot
tot[1,]<-freq_obj_tot[1]
tot[2,]<-c(1:length(dictionary))
View(tot)
to<-rbind(freq_obj_tot,c(1:length(dictionary))
)
View(to)
rm(tot)
tot<-rbind(freq_obj_tot,c(1:length(dictionary)))
rm(to)
tot[1,]=tot[1,]/nrow(ins.stima) #freq relative
View(tot)
for(i in 1:ncol(tot))
{
tot[1,i]=tot[1,i]/nrow(ins.stima) #freq relative
}
View(tot)
rm(tot)
freq_obj_tot=freq_obj_tot/nrow(ins.stima) #freq assolute
View(freq_obj_tot)
7/800
tot<-rbind(freq_obj_tot,c(1:length(dictionary)))
tot[1,]
#ordiamo in base alle freq relative
ord_obj=matrix(sort(tot[1,],decreasing=T),nrow = nrow(tot),ncol=ncol(tot))
View(ord_obj)
rm(ord_obj)
tot[order(tot[1,])]
tot2<-data.frame(freq_obj_tot,c(1:length(dictionary)))
View(tot2)
rm(tot2)
sort(tot,decrease=TRUE)
sort(tot,decreasing=TRUE)
sort(tot[1,],decreasing=TRUE)
a=sort(tot[1,],decreasing=TRUE)
tot[2,][order(tot[1,])]
View(tot)
rm(a)
sort(tot[1,],tot[2,],decreasing=TRUE)
tot[2,][order(tot[1,])]
count=0
for(i in 1: ncol(tot))
{
if (tot[1,i]!=0)
#print(i)
count=count+1
}
count
freq_rel=matrix(0,2,count)
for(i in 1: ncol(ord_obj))
{
if (tot[,i]!=0)
{
freq_rel[1,i]= tot[1,i]
freq_rel[2,i]= tot[2,i]
}
}
freq_rel=matrix(0,2,count)
for(i in 1: ncol(tot))
{
if (tot[,i]!=0)
{
freq_rel[1,i]= tot[1,i]
freq_rel[2,i]= tot[2,i]
}
}
warnings()
tot[order(tot[1,]),decreasing=TRUE]
tot[order(tot[1,])]
orderBy(tot, tot[1,i])
order_by(tot, tot[1,i])
order_by(tot[2,], tot[1,i])
order_by(tot, tot[1,i])
sort(tot)
sort(tot,decreasing=TRUE)
View(tot)
tot<-rbind(freq_obj_tot,c(1:length(dictionary)))
View(tot)
c(1:length(dictionary))
rm(tot4)
rm(tot)
#uniamo le freq relative con la riga che conta il numero di colonne (ci serve per poi mettere il nome alle colonne)
tot<-rbind(freq_obj_tot,c(1:length(dictionary)))
View(tot)
#uniamo le freq relative con la riga che conta il numero di colonne (ci serve per poi mettere il nome alle colonne)
tot<-rbind(freq_obj_tot,int(1:length(dictionary)))
#uniamo le freq relative con la riga che conta il numero di colonne (ci serve per poi mettere il nome alle colonne)
tot<-rbind(freq_obj_tot,as.integer(1:length(dictionary)))
#uniamo le freq relative con la riga che conta il numero di colonne (ci serve per poi mettere il nome alle colonne)
tot<-rbind(freq_obj_tot,as.integer(1:length(dictionary)))
View(tot)
pippo<-(1:length(dictionary))
pippo<-c(1:length(dictionary))
pippo[order(freq_obj_tot)]
arrange(pippo,sort(freq_obj_tot))
arrange(as.numeric(pippo),sortas.numeric((freq_obj_tot))
)
